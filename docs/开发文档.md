# Ticket System 开发文档

## 分工

|  组员  |          分工          |
| :----: | :--------------------: |
| 范棋珈 | 后端逻辑、前端（暂定） |
|  韦捷  |  B+ 树、字符串解析类   |

## 程序功能概述

- 程序最终呈现一个和12306相类似的火车票管理系统。
- 程序首次创建账户时不需要指定当前用户，并且默认用户优先级为10（最高优先级）。
- 指令中第一个部分必须为指令关键词，指令中关键词部分必须与指令格式完全匹配。
- 系统支持嵌套登录，即允许多个账户同时处于登录状态
- `quit` 和 `exit` 指令功能为正常退出系统，退出系统视为登出所有已登录账户

## 文件结构 & 运行逻辑

```
.
├── .gitignore
├── CMakeLists.txt
├── docs
│   ├── 开发文档.md
│   └── 前端 开发文档.md
├── lib
│   ├── bplustree.hpp
│   ├── exceptions.hpp
│   ├── test_logic.hpp
│   ├── unordered_map.hpp
│   ├── utils.hpp
│   └── vector.hpp
├── LICENSE
├── README.md
├── src
│   ├── commands.hpp
│   ├── main.cpp
│   ├── trains.hpp
│   └── users.hpp
└── src_rollback
    ├── commands.hpp
    ├── main.cpp
    ├── rollback.hpp
    ├── trains.hpp
    └── users.hpp
```

- `lib/` 中含有一些需要用到的数据结构和工具类、函数的代码，如 B+ 树、vector、linked_hashmap（为方便与 STL 互通，在代码中的类名为 unordered_map） 等，`utils.hpp` 里主要含有快速排序、字符串解析类、定长字符串类、哈希函数类、时间日期类等~~，`test_logic.hpp` 是用 `std::map` 实现的假内存 B+ 树，仅用于测试逻辑主体~~。
- `src/` 中为主体逻辑代码：
  - `main.cpp` 为主入口，将输入的指令传给命令解析类，并负责将返回的信息输出。
  - `commands.hpp` 负责解析命令，调用对应的执行函数。
  - `users.hpp` 里含有用户管理类，执行和用户相关的操作。
  - `trains.hpp` 里含有火车管理类，执行和火车相关的操作，包括但不限于添加/删除车次、查票、买票、管理订单等。
- `src_rollback/` 中为含有回滚功能的主体逻辑代码，其中 `rollback.hpp` 中含有包装类，能够管理数据库的操作历史记录。
- 通过 `CMakeLists.txt` 控制是否含有回滚功能。 

## 数据存储结构

### 主要内存：

- 登录表，并存下登录用户的权限。

### 维护以下的 B+ 树（外存）：

- userID  ——> 用户信息（或者其存储位置）
- trainID ——> 火车信息（或者其存储位置）
- （站名，trainID）——> 火车在车站的信息
- （trainID，日期）——> 火车票量信息
- （userID，时刻）——> 订单信息
- （<trainID, 日期>，时刻）——> 候补订单信息

> 为优化 B+ 树内的比较操作时间，上文的“ID”均为哈希值。

*注意：字符类型的情况下需用定长字符类而非 `std::string` 完成，否则无法正常读写。*

## 实现框架

### 工具类 & 数据结构

#### 字符串解析类（in `utils.hpp`）

大致功能是将字符串分割成多个语素返回。

```c++
class TokenScanner{
    //char delimiter_ = ' '; //分隔符
    int current_ = 0; //所在的位置
    std::string buffer_; //储存的字符串缓冲区
public:
    TokenScanner() = default;
    TokenScanner(std::string &);
    std::string NextToken(char delimiter_ = ' ');
    std::string NextToken(char delimiter_head_, char delimiter_tail_, bool ck = false);
    void Clear();
    bool If_left(char delimiter_ = ' ');
    std::string Getleft(char delimiter_ = ' ');
}
```

#### 定长字符串类（in `utils.hpp`）

```c++
// 为文件读写而写的定长字符串类。
template <int len>
class FixedStr {
  char str[len + 1]{};

 public:
  FixedStr();
  // 支持与 std::string 类型的相互转换，其中转为 std::string 需显式。
  FixedStr(const string &obj);
  explicit operator string() const { return str; }

  char &operator[](const int &index);
  const char operator[](const int &index) const;

  friend bool operator<(const FixedStr<len> &, const FixedStr<len> &);
  friend bool operator<=(const FixedStr<len> &, const FixedStr<len> &);
  friend bool operator<(const FixedStr<len> &, const FixedStr<len> &);
  friend bool operator<=(const FixedStr<len> &, const FixedStr<len> &);
  friend bool operator==(const FixedStr<len> &, const FixedStr<len> &);
  friend bool operator!=(const FixedStr<len> &, const FixedStr<len> &);
};
```

#### B+ 树（in `bplustree.hpp`）

键值对形式为（第一关键字，第二关键字，值），便于存储和查找第一关键字相同的所有元素。

```c++
// M 为 B+ 树阶数，L 为块大小（存储的元素个数）。
template <typename _key_type,typename _subkey_type,typename _value_type, int M, int L>
class BPlusTree{
    std::fstream file_node_;   // 索引节点存储文件流
    std::fstream file_block_;  // 数据块节点存储文件流
    // CACHE
    const size_t cache_size;
    unordered_map<pair<_key_type, _subkey_type>, _value_type, PairHash<_key_type, _subkey_type>> cache;
public:
    std::string filename_node;
    std::string filename_block;
    BPlusTree(std::string name1, std::string name2);
    // CACHE
    // 将对应键值对插入缓存。
    void ToCache(const _key_type& key, const _subkey_type& subkey, const _value_type& value);
    // 返回所存的元素个数。
    int Size();
    // 插入键值对。
    bool Insert(const _key_type& key, const _subkey_type& subkey, const _value_type& value);
    // 删除键值对。
    bool Delete(const _key_type& key, const _subkey_type& subkey);
    // 修改对应键的值，
    bool Modify(const _key_type& key, const _subkey_type& subkey, const _value_type& value);
    // 清空数据。
    void Clear();
    // 查找是否存在给定第一关键字的元素。
    bool Exist(const _key_type& key);
    // 查找是否存在与给定第一、第二关键字相同的元素。
    bool Exist(const _key_type& key, const _subkey_type& subkey);
    // 返回第一关键字与给定关键字相同的所有元素。
    vector<_value_type> Traverse(const _key_type& key);
    // 返回第一关键字大于等于给定关键字的所有元素。
    vector<_value_type> GetSuf(const _key_type& key);
    // CACHE
    // 返回对应关键字均相同的元素。
    [[nodiscard]] _value_type Get(const _key_type& key, const _subkey_type& subkey);
};
```

其中阶数和块大小根据模板类型的大小手动计算。

##### 缓存

目前针对较为频繁的单点查询操作实现了一个简易缓存（见代码 `// CACHE` 部分）。思路是在类中开一个限制大小的 linked_hashmap，在每次单点查询时：

1. 在缓存里查找元素；
2. 若存在待查找元素则直接返回；
3. 否则在 B+ 树中查找，查到后存入缓存；
4. 若发现缓存超出限定大小，则弹出最早加入的元素。

在修改、删除时顺带要修改一下缓存内元素。

#### 回滚包装类（in `rollback.hpp`）

类名为 `BptPlus`~~（B+ 树增强版）~~，内部含有两个 B+ 树，一个存储数据，一个按照时间戳顺序存储历史记录。其中查询类操作将直接调用数据 B+ 树中的对应函数，而含有修改的操作（插入、删除、修改）将新增历史记录。回滚时按栈序撤销操作。

```c++
// M 为 B+ 树阶数，L 为块大小（存储的元素个数），LL 为历史记录的块大小。
template <class _key_type, class _subkey_type, class _value_type, int M, int L,
          int LL>
class BptPlus {
  struct History {
    enum Opt { INSERT, DELETE, MODIFY };
    _key_type key;
    _subkey_type subkey;
    Opt opt;
    int timestamp, cnt;
    _value_type value;
    // 构造函数略。
  };
  int last_stamp{0}, cnt;
  BPlusTree<_key_type, _subkey_type, _value_type, M, L> data;  // 数据 B+ 树
  BPlusTree<int, int, History, 253, LL> history;               // 历史记录存储

 public:
  // 构造函数略。
  void Insert(const int &timestamp, const _key_type &key,
              const _subkey_type &subkey, const _value_type &value);
  bool Delete(const int &timestamp, const _key_type &key,
              const _subkey_type &subkey);  // 返回是否删除成功。
  void Modify(const int &timestamp, const _key_type &key,
              const _subkey_type &subkey, const _value_type &value);

  int Size() const;
  bool Exist(const _key_type &key, const _subkey_type &subkey);
  _value_type Get(const _key_type &key, const _subkey_type &subkey);
  vector<_value_type> Traverse(const _key_type &key);

  void RollBack(const int &timestamp, const int &now);
  void Clear();
};
```

### 用户部分

#### 用户信息类（in `users.hpp`）

```c++
class User {
  // 为了文件存储需要定长。
  FixedStr<20> username;   // 用户名
  FixedStr<30> password;   // 密码
  FixedStr<20> name;       // 真实姓名
  FixedStr<30> mail_addr;  // 邮件地址
  int privilege;           // 权限 [0, 10] 

 public:
   // ...
};
```

#### 用户管理类（in `users.hpp`）

```c++
class UserManagement {
  BptPlus<size_t, int, User, 339, 67, 55> users;  // username_hash -> user
  unordered_map<string, int> login;               // 登录表

 public:
  UserManagement();
  bool IsLogin(const string &) const;
  // 成功返回 1，失败返回 0.
  bool AddUser(const string &cur_username, const string &username,
               const string &password, const string &name,
               const string &mail_addr, int &privilege, const int &timestamp);
  bool Login(const string &username, const string &password);
  bool Logout(const string &username);
  string QueryProfile(const string &cur_username, const string &username);
  string ModifyProfile(const string &cur_username, const string &username,
                       const string &password, const string &name,
                       const string &mail_addr, int &privilege,
                       const int &timestamp);

  void RollBack(const int &timestamp, const int &now);
  void Clean();
};
```

### 火车 & 车票部分

#### 火车信息（in `trains.hpp`）

```c++
struct Train {
  static constexpr int kStNum{100};  // 0-base
  FixedStr<20> train_id;
  int seat_num, station_num;
  FixedStr<40> stations[kStNum];
  int prices[kStNum]{};      // 累计价格。
  int arr_times[kStNum]{};   // 到达累计时间。
  int dept_times[kStNum]{};  // 出发累计时间。
  Time start_time;
  Date begin_date, end_date;
  char type{'\0'};
  bool is_release{0};
};
```

#### 火车在车站的信息（in `trains.hpp`）

```c++
struct StationTrain {
  size_t trainid;            // 火车 ID 的哈希值。
  FixedStr<20> train_id;
  Time arr_time, dept_time;  // 里面存的是相对起点站发车的时间。
  int order{-1}, price;      // 该车经过的第几个车站、累计票价。
};
```

#### 火车票量信息（in `trains.hpp`）

由于车站数不多，直接使用数组记录相邻车站间的票量。

```c++
class TicketTrain {
  // 维护每个站区间内的票数。
  int cnt[100];

 public:
  int station_num, seat;
  // 构造函数略。
  int QueryTicket(int l, int r) const;
  void BuyTickets(int l, int r, int v);
};
```

#### 订单信息（in `trains.hpp`）

```c++
struct Order {
  enum Status { SUCCESS, PENDING, REFUNDED };
  Status status;
  int timestamp, price, cnt;
  Date dept_date;  // 该列车在始发站的出发日期，用于确认具体车辆信息。
  FixedStr<20> username, train_id;
  FixedStr<40> dept, arr;
  int s_order, t_order;          // 出发、到达站在该列车运行时刻表中的次序。
  DateTime dept_time, arr_time;  // 出发、到达时间。

  explicit operator string() const;  // 支持显示转换为 std::string
};
```

#### 候补订单信息（in `trains.hpp`）

```c++
struct PendingInfo {
  int timestamp, need, s_order, t_order;  // 时间戳，需要票数，出发、到达站在该列车运行时刻表中的次序。
  size_t userid, trainid;
};
```

#### 火车管理类（in `trains.hpp`）

```c++
class TrainManagement {
  // trainid -> train
  BptPlus<size_t, int, Train, 339, 2, 2> trains;
  // trainid -> train_date
  BptPlus<size_t, int, TrainDate, 339, 203, 144> train_dates;
  // (stationid, trainid) -> station_train
  BptPlus<size_t, size_t, StationTrain, 339, 101, 77> station_trains;
  // (trainid, date) -> ticket_of_train
  BptPlus<size_t, Date, TicketTrain, 339, 18, 17> ticket_trains;
  // (userid, -timestamp) -> order  后到先输出
  BptPlus<size_t, int, Order, 339, 38, 34> orders;
  // (<trainid, date>, timestamp) -> pending_info  先到先得
  BptPlus<pair<size_t, Date>, int, PendingInfo, 254, 144, 112> pending_orders;

 public:
  // 构造函数略。
  // 由于一列车的信息量，添加火车时将 token 直接传入管理类。
  bool AddTrain(TokenScanner &token, const int &timestamp);
  bool DeleteTrain(const string &train_id, const int &timestamp);
  bool ReleaseTrain(const string &train_id, const int &timestamp);
  string QueryTrain(const Date &date, const string &train_id);
  // prior 默认为 0，表示 time，否则为 cost.
  string QueryTicket(const string &dept, const string &arr, const Date &date,
                     const bool &prior);
  string QueryTransfer(const string &dept, const string &arr, const Date &date,
                       const bool &prior);
  // 用户已登录。
  string BuyTicket(const string &username, const string &train_id,
                   const Date &date, const string &dept, const string &arr,
                   const int &cnt, const bool &will_wait,
                   const int &timestamp);
  string QueryOrder(const string &username);
  bool RefundTicket(const string &username, const unsigned &rank,
                    const int &timestamp);
  void RollBack(const int &timestamp, const int &now);
  void Clean();
};
```



